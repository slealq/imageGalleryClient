---
interface Props {
    imageId: string;
}

const { imageId } = Astro.props;
---

<!-- Caption Modal - Appears on top of the FullscreenModal -->
<div id="caption-modal" class="fixed inset-0 bg-black/90 hidden z-[60] flex items-center justify-center transition-opacity duration-200">
    <div id="caption-box" class="bg-gray-900/90 rounded-lg p-6 w-full max-w-2xl mx-4 transition-opacity duration-200 relative">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-semibold text-white">Image Caption</h2>
            <div class="flex items-center gap-4">
                <div class="text-sm text-gray-400">
                    Background: <span id="opacity-value">90</span>%<br>
                    Box: <span id="box-opacity-value">90</span>%
                </div>
                <button id="close-caption-modal" class="text-gray-400 hover:text-white">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
        </div>
        <div class="space-y-4">
            <textarea id="caption-text" class="w-full h-32 bg-gray-800 text-white rounded-lg p-3 resize-none focus:ring-2 focus:ring-blue-500 focus:outline-none" placeholder="Enter caption..."></textarea>
            <div class="flex gap-3">
                <button id="generate-caption" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-sm font-medium transition-colors">
                    Generate Caption
                </button>
                <button id="save-caption" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg text-sm font-medium transition-colors">
                    Save Caption
                </button>
            </div>
        </div>
        <div id="timer" class="absolute bottom-2 right-2 text-sm text-gray-400 hidden">
            Generating: <span id="timer-value">0</span>s
        </div>
    </div>
</div>

<script>
    import { getImageCaption, saveImageCaption, generateImageCaption } from '../utils/api';

    let captionModal: HTMLElement | null = null;
    let captionBox: HTMLElement | null = null;
    let captionText: HTMLTextAreaElement | null = null;
    let generateCaptionBtn: HTMLElement | null = null;
    let saveCaptionBtn: HTMLElement | null = null;
    let closeCaptionModalBtn: HTMLElement | null = null;
    let currentImageId: string | null = null;
    let opacityValue: HTMLElement | null = null;
    let boxOpacityValue: HTMLElement | null = null;
    let currentOpacity = parseInt(localStorage.getItem('captionBackgroundOpacity') || '90');
    let currentBoxOpacity = parseInt(localStorage.getItem('captionBoxOpacity') || '90');
    let timerElement: HTMLElement | null = null;
    let timerValue: HTMLElement | null = null;
    let timerInterval: number | null = null;
    let startTime: number | null = null;

    function updateOpacity(value: number) {
        currentOpacity = value;
        if (captionModal) {
            captionModal.style.backgroundColor = `rgba(0, 0, 0, ${value / 100})`;
        }
        if (opacityValue) {
            opacityValue.textContent = value.toString();
        }
        // Save to localStorage
        localStorage.setItem('captionBackgroundOpacity', value.toString());
    }

    function updateBoxOpacity(value: number) {
        currentBoxOpacity = value;
        if (captionBox) {
            captionBox.style.backgroundColor = `rgba(17, 24, 39, ${value / 100})`; // gray-900 with opacity
        }
        if (boxOpacityValue) {
            boxOpacityValue.textContent = value.toString();
        }
        // Save to localStorage
        localStorage.setItem('captionBoxOpacity', value.toString());
    }

    function updateCaptionStatus(hasCaption: boolean) {
        const statusDot = document.querySelector('#caption-status .w-2');
        const statusText = document.querySelector('#caption-status span:last-child');
        if (statusDot && statusText) {
            statusDot.className = `w-2 h-2 rounded-full ${hasCaption ? 'bg-green-500' : 'bg-red-500'}`;
            statusText.textContent = hasCaption ? 'Has Caption' : 'No Caption';
        }
    }

    function startTimer() {
        if (timerElement && timerValue) {
            timerElement.classList.remove('hidden');
            timerValue.textContent = '0';
            startTime = Date.now();
            timerInterval = window.setInterval(() => {
                if (startTime && timerValue) {
                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                    timerValue.textContent = elapsed.toString();
                }
            }, 1000);
        }
    }

    function stopTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
        if (timerElement) {
            timerElement.classList.add('hidden');
        }
        startTime = null;
    }

    async function loadCaption() {
        if (!currentImageId || !captionText) return;
        try {
            const caption = await getImageCaption(currentImageId);
            captionText.value = caption;
            updateCaptionStatus(caption.length > 0);
        } catch (error) {
            console.error('Error loading caption:', error);
            updateCaptionStatus(false);
        }
    }

    async function handleGenerateCaption() {
        if (!currentImageId || !captionText) return;
        try {
            // Add visual feedback and disable button
            generateCaptionBtn?.classList.add('bg-purple-800', 'opacity-50', 'cursor-not-allowed');
            generateCaptionBtn?.setAttribute('disabled', 'true');
            
            // Start the timer
            startTimer();
            
            const generatedCaption = await generateImageCaption(currentImageId);
            captionText.value = generatedCaption;
        } catch (error) {
            console.error('Error generating caption:', error);
        } finally {
            // Stop the timer
            stopTimer();
            
            // Remove visual feedback and re-enable button
            generateCaptionBtn?.classList.remove('bg-purple-800', 'opacity-50', 'cursor-not-allowed');
            generateCaptionBtn?.removeAttribute('disabled');
        }
    }

    async function handleSaveCaption() {
        if (!currentImageId || !captionText) return;
        try {
            // Add visual feedback
            saveCaptionBtn?.classList.add('bg-green-800');
            
            await saveImageCaption(currentImageId, captionText.value);
            updateCaptionStatus(captionText.value.length > 0);
            
            // Update the data attributes on the image element
            const imageElement = document.querySelector(`img[data-id="${currentImageId}"]`);
            if (imageElement) {
                imageElement.setAttribute('data-has-caption', captionText.value.length > 0 ? 'true' : 'false');
            }
            
            // Wait for visual feedback before closing
            setTimeout(() => {
                saveCaptionBtn?.classList.remove('bg-green-800');
                captionModal?.classList.add('hidden');
            }, 200);
        } catch (error) {
            console.error('Error saving caption:', error);
            // Remove visual feedback on error
            saveCaptionBtn?.classList.remove('bg-green-800');
        }
    }

    // Initialize modal elements
    document.addEventListener('DOMContentLoaded', () => {
        captionModal = document.getElementById('caption-modal');
        captionBox = document.getElementById('caption-box');
        captionText = document.getElementById('caption-text') as HTMLTextAreaElement;
        generateCaptionBtn = document.getElementById('generate-caption');
        saveCaptionBtn = document.getElementById('save-caption');
        closeCaptionModalBtn = document.getElementById('close-caption-modal');
        opacityValue = document.getElementById('opacity-value');
        boxOpacityValue = document.getElementById('box-opacity-value');
        timerElement = document.getElementById('timer');
        timerValue = document.getElementById('timer-value');

        // Close caption modal button handler
        closeCaptionModalBtn?.addEventListener('click', () => {
            captionModal?.classList.add('hidden');
        });

        // Generate caption button handler
        generateCaptionBtn?.addEventListener('click', handleGenerateCaption);

        // Save caption button handler
        saveCaptionBtn?.addEventListener('click', handleSaveCaption);

        // Add keyboard shortcuts for caption operations
        document.addEventListener('keydown', (e) => {
            // Only handle shortcuts if caption modal is open
            if (captionModal?.classList.contains('hidden')) return;

            // Handle arrow keys for box opacity control
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
                const change = e.key === 'ArrowUp' ? 5 : -5;
                if (e.metaKey) {
                    // Command + Arrow controls background opacity
                    const newOpacity = Math.min(Math.max(currentOpacity + change, 20), 100);
                    updateOpacity(newOpacity);
                } else {
                    // Arrow keys control box opacity
                    const newBoxOpacity = Math.min(Math.max(currentBoxOpacity + change, 20), 100);
                    updateBoxOpacity(newBoxOpacity);
                }
                return;
            }

            // Allow left/right arrows to pass through for image navigation
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                return;
            }

            // Handle Enter key to focus textarea
            if (e.key === 'Enter' && !document.activeElement?.id.includes('caption-text')) {
                e.preventDefault();
                if (captionText) {
                    captionText.focus();
                    captionText.select();
                }
                return;
            }

            // Don't handle shortcuts if we're typing in the textarea
            const activeElement = document.activeElement;
            if (activeElement?.id === 'caption-text') return;

            // Handle g and s keys directly when textarea is not focused
            switch (e.key.toLowerCase()) {
                case 'g':
                    e.preventDefault();
                    handleGenerateCaption();
                    return;
                case 's':
                    e.preventDefault();
                    handleSaveCaption();
                    return;
            }

            // Check for Command key combinations
            if (e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'g':
                        e.preventDefault(); // Prevent default browser behavior
                        handleGenerateCaption();
                        break;
                    case 's':
                        e.preventDefault(); // Prevent default browser behavior
                        handleSaveCaption();
                        break;
                }
            } else {
                // Block all other key events when caption modal is open
                e.preventDefault();
            }
        });
    });

    // Make functions available globally
    (window as any).openCaptionModal = (imageId: string) => {
        currentImageId = imageId;
        captionModal?.classList.remove('hidden');
        // Apply saved opacity values
        updateOpacity(currentOpacity);
        updateBoxOpacity(currentBoxOpacity);
        // Clear the textarea before loading new caption
        if (captionText) {
            captionText.value = '';
        }
        loadCaption();
    };
</script> 