---
import CaptionModal from './CaptionModal.astro';
import CropModal from './CropModal.astro';
import { ImageManager } from '../utils/ImageManager';

interface Props {
    imageUrl?: string;
}

const { imageUrl } = Astro.props;
---

<div id="modal" class="fixed inset-0 bg-black/90 hidden z-50 flex items-center justify-center">
    <div class="relative w-full h-full flex flex-col">
        <div id="modal-background" class="flex-1 flex items-center justify-center p-4 pb-20">
            <img id="modal-image" src="" alt="" class="max-w-[95vw] max-h-[95vh] w-auto h-auto object-contain" />
        </div>
        <div id="modal-footer" class="absolute bottom-0 left-0 right-0 bg-black/50 backdrop-blur-sm p-4 text-white text-sm">
            <div class="container mx-auto">
                <div class="flex justify-between items-center mb-2">
                    <div id="modal-filename" class="font-medium"></div>
                    <div class="flex gap-4">
                        <div id="modal-size" class="text-gray-300"></div>
                        <div id="modal-date" class="text-gray-300"></div>
                    </div>
                </div>
                <div class="flex items-center gap-4">
                    <div id="caption-status" class="flex items-center gap-2">
                        <span class="w-2 h-2 rounded-full"></span>
                        <span class="text-sm">Caption Status</span>
                    </div>
                    <button id="caption-button" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium transition-colors cursor-pointer">
                        Manage Caption
                    </button>

                    <div id="crop-status" class="flex items-center gap-2">
                        <span class="w-2 h-2 rounded-full"></span>
                        <span class="text-sm">Crop Status</span>
                    </div>
                    <button id="crop-button" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-sm font-medium transition-colors cursor-pointer">
                        Crop Image
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<CaptionModal imageId="" />
<CropModal imageId="" />

<script>
    import { getCroppedImage } from '../utils/api';
    import { ImageManager } from '../utils/ImageManager';

    let modal: HTMLElement | null = null;
    let modalImage: HTMLImageElement | null = null;
    let modalFilename: HTMLElement | null = null;
    let modalSize: HTMLElement | null = null;
    let modalDate: HTMLElement | null = null;
    let captionButton: HTMLElement | null = null;
    let imageElements: HTMLImageElement[] = [];
    let currentImageIndex = -1;
    let isLoadingMore = false;
    let currentImageId: string | null = null;
    let originalImageUrl: string | null = null;

    function formatFileSize(bytes: number): string {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function formatDate(dateString: string): string {
        const date = new Date(dateString);
        return date.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    function updateStatuses(imageId: string) {
        const properties = window.imageManager.getImageProperties(imageId);
        if (!properties) return;

        // Update caption status
        const statusDot = document.querySelector('#caption-status .w-2');
        const statusText = document.querySelector('#caption-status span:last-child');
        if (statusDot && statusText) {
            statusDot.className = `w-2 h-2 rounded-full ${properties.has_caption ? 'bg-green-500' : 'bg-red-500'}`;
            statusText.textContent = properties.has_caption ? 'Has Caption' : 'No Caption';
        }

        // Update crop status
        const cropStatusDot = document.querySelector('#crop-status .w-2');
        const cropStatusText = document.querySelector('#crop-status span:last-child');
        if (cropStatusDot && cropStatusText) {
            cropStatusDot.className = `w-2 h-2 rounded-full ${properties.has_crop ? 'bg-green-500' : 'bg-red-500'}`;
            cropStatusText.textContent = properties.has_crop ? 'Has Crop' : 'No Crop';
        }
    }

    async function navigateImage(direction: 'next' | 'prev') {
        if (currentImageIndex === -1) return;
        
        let newIndex = direction === 'next' 
            ? Math.min(currentImageIndex + 1, imageElements.length - 1)
            : Math.max(currentImageIndex - 1, 0);
            
        if (direction === 'next' && currentImageIndex === imageElements.length - 1 && !isLoadingMore) {
            isLoadingMore = true;
            try {
                if (window.loadMoreImages) {
                    const success = await window.loadMoreImages();
                    if (success) {
                        imageElements = Array.from(document.querySelectorAll('img[data-filename]')) as HTMLImageElement[];
                        if (currentImageIndex < imageElements.length - 1) {
                            newIndex = currentImageIndex + 1;
                        }
                    }
                }
            } finally {
                isLoadingMore = false;
            }
        }
            
        if (newIndex !== currentImageIndex) {
            currentImageIndex = newIndex;
            const img = imageElements[currentImageIndex];
            const imageId = img.getAttribute('data-id');
            
            if (imageId) {
                const image = await window.imageManager.createImageFromUrl(
                    img.src,
                    imageId,
                    img.getAttribute('data-filename') || '',
                    parseInt(img.getAttribute('data-size') || '0'),
                    img.getAttribute('data-created') || ''
                );
                currentImageId = imageId;
                
                if (modalImage) {
                    modalImage.src = image.getUrl();
                    originalImageUrl = image.getUrl();
                }
                if (modalFilename) modalFilename.textContent = image.getFilename();
                if (modalSize) modalSize.textContent = formatFileSize(image.getSize());
                if (modalDate) modalDate.textContent = formatDate(image.getCreated());

                updateStatuses(imageId);

                // If caption modal is open, update it with the new image's caption
                const captionModal = document.getElementById('caption-modal');
                if (captionModal && !captionModal.classList.contains('hidden')) {
                    (window as any).openCaptionModal(imageId);
                }
            }
        }
    }

    async function openModal(
        imageUrl: string,
        filename: string,
        size: string,
        created: string,
        imageId: string,
        hasCaption: boolean,
        hasTags: boolean,
        collectionName: string
    ) {
        if (!modal || !modalImage || !modalFilename || !modalSize || !modalDate) return;
        
        currentImageId = imageId;
        originalImageUrl = imageUrl;
        
        // Update image elements list
        imageElements = Array.from(document.querySelectorAll('img[data-filename]')) as HTMLImageElement[];
        
        // Find the image that matches this URL
        const img = imageElements.find(img => img.src === imageUrl);
        
        if (img) {
            currentImageIndex = imageElements.indexOf(img);
            const image = await window.imageManager.createImageFromUrl(
                imageUrl,
                imageId,
                filename,
                parseInt(size),
                created
            );
            
            modalImage.src = image.getUrl();
            modalFilename.textContent = image.getFilename();
            modalSize.textContent = formatFileSize(image.getSize());
            modalDate.textContent = formatDate(image.getCreated());
            
            modal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';

            updateStatuses(imageId);
        }
    }

    function closeModal() {
        if (!modal) return;
        modal.classList.add('hidden');
        document.body.style.overflow = '';
    }

    // Function to update the modal image with the cropped version
    async function updateCropImage() {
        if (!currentImageId || !modalImage) return;
        
        try {
            const image = window.imageManager.getImage(currentImageId);
            if (!image) return;

            const blob = await image.getCroppedImage();
            if (blob) {
                const blobUrl = URL.createObjectURL(blob);
                
                // Clean up previous blob URL if it exists
                if (modalImage.src.startsWith('blob:')) {
                    URL.revokeObjectURL(modalImage.src);
                }
                
                modalImage.src = blobUrl;
            }
        } catch (error) {
            console.error('Error fetching cropped image:', error);
        }
    }

    // Initialize modal elements
    document.addEventListener('DOMContentLoaded', () => {
        modal = document.getElementById('modal');
        modalImage = document.getElementById('modal-image') as HTMLImageElement;
        modalFilename = document.getElementById('modal-filename');
        modalSize = document.getElementById('modal-size');
        modalDate = document.getElementById('modal-date');
        captionButton = document.getElementById('caption-button');

        // Get all image elements
        imageElements = Array.from(document.querySelectorAll('img[data-filename]')) as HTMLImageElement[];

        // Close modal when clicking outside the image
        modal?.addEventListener('click', (e) => {
            const target = e.target as HTMLElement;
            if (target.id === 'modal-background') {
                closeModal();
            }
        });

        // Caption button click handler
        captionButton?.addEventListener('click', () => {
            if (currentImageId) {
                updateCropImage();
                (window as any).openCaptionModal(currentImageId);
            }
        });

        // Add keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Check if caption modal is open
                const captionModal = document.getElementById('caption-modal');
                const captionText = document.getElementById('caption-text');
                
                if (captionModal && !captionModal.classList.contains('hidden')) {
                    // If textarea is focused, just blur it
                    if (document.activeElement?.id === 'caption-text') {
                        captionText?.blur();
                        e.preventDefault();
                        return;
                    }
                    // Otherwise close caption modal
                    captionModal.classList.add('hidden');
                    e.preventDefault();
                    return;
                }
                
                // If main modal is open, close it
                if (modal && !modal.classList.contains('hidden')) {
                    closeModal();
                    e.preventDefault();
                    return;
                }
            }

            // Only handle other keys if main modal is open
            if (modal?.classList.contains('hidden')) return;
            
            // Don't handle shortcuts if we're typing in the caption textarea
            const activeElement = document.activeElement;
            if (activeElement?.id === 'caption-text') return;
            
            switch (e.key) {
                case 'ArrowLeft':
                    navigateImage('prev');
                    break;
                case 'ArrowRight':
                    navigateImage('next');
                    break;
                case 'c':
                    // Open caption modal if main modal is open
                    if (currentImageId) {
                        (window as any).openCaptionModal(currentImageId);
                    }
                    break;
                case 'r':
                    // Open crop modal if main modal is open
                    if (currentImageId) {
                        (window as any).openCropModal(currentImageId);
                    }
                    break;
            }
        });

        // Add crop button handler
        const cropButton = document.getElementById('crop-button');
        cropButton?.addEventListener('click', () => {
            if (currentImageId) {
                (window as any).openCropModal(currentImageId);
            }
        });

        // Listen for crop modal open/close
        const cropModal = document.getElementById('crop-modal');
        if (cropModal) {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.attributeName === 'class') {
                        const isHidden = cropModal.classList.contains('hidden');
                        if (!isHidden && currentImageId && modalImage) {
                            // When crop modal opens, show cropped version
                            updateCropImage();
                        } else if (isHidden && originalImageUrl && modalImage) {
                            // When crop modal closes, show original version
                            modalImage.src = originalImageUrl;
                        }
                    }
                });
            });

            observer.observe(cropModal, { attributes: true });
        }

        // Listen for caption modal open/close
        const captionModal = document.getElementById('caption-modal');
        if (captionModal) {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.attributeName === 'class') {
                        const isHidden = captionModal.classList.contains('hidden');
                        if (!isHidden && currentImageId && modalImage) {
                            // When caption modal opens, re-fetch the image
                            updateCropImage();
                        } else if (isHidden && currentImageId) {
                            // When caption modal closes, update the status
                            updateStatuses(currentImageId);
                        }
                    }
                });
            });

            observer.observe(captionModal, { attributes: true });
        }

        // Listen for crop application
        const applyCropButton = document.getElementById('apply-crop');
        if (applyCropButton) {
            applyCropButton.addEventListener('click', () => {
                // Wait a short moment for the server to process the crop
                setTimeout(() => {
                    // Revert to original image after applying crop
                    if (originalImageUrl && modalImage) {
                        modalImage.src = originalImageUrl;
                    }
                }, 100);
            });
        }
    });

    // Make openModal available globally
    (window as any).openModal = openModal;
</script> 