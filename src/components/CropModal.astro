---
interface Props {
    imageId: string;
}

const { imageId } = Astro.props;
---

<!-- Crop Modal -->
<div id="crop-modal" class="fixed inset-0 bg-black/90 hidden z-[70] flex items-center justify-center">
    <div class="relative w-full h-full flex flex-col">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-semibold text-white">Crop Image</h2>
            <div class="flex items-center gap-4">
                <div class="flex gap-2">
                    <button id="crop-original" class="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm text-white">
                        Original
                    </button>
                    <button id="crop-512" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm text-white">
                        512x512
                    </button>
                    <button id="crop-768" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm text-white">
                        768x768
                    </button>
                    <button id="crop-1024" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm text-white">
                        1024x1024
                    </button>
                </div>
                <button id="close-crop-modal" class="text-gray-400 hover:text-white">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
        </div>
        
        <div id="modal-background" class="flex-1 flex items-center justify-center p-4 pb-20">
            <div class="relative">
                <img id="crop-preview" src="" alt="" class="max-w-[95vw] max-h-[95vh] w-auto h-auto object-contain" />
                <div id="crop-box" class="absolute inset-0 border-2 border-red-500 bg-red-500/20"></div>
            </div>
        </div>

        <div class="absolute bottom-0 left-0 right-0 bg-black/50 backdrop-blur-sm p-4">
            <div class="flex justify-end gap-3">
                <button id="cancel-crop" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm font-medium text-white">
                    Cancel
                </button>
                <button id="apply-crop" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium text-white">
                    Apply Crop
                </button>
            </div>
        </div>
    </div>
</div>

<script>
    import { getImageUrl, getImagePreviewUrl, cropImage } from '../utils/api';

    class CropboxHandler {
        imagePreviewElement: HTMLImageElement;
        cropBoxElement: HTMLElement;

        constructor(
            imagePreviewElement: HTMLImageElement,
            cropBoxElement: HTMLElement) {
            this.imagePreviewElement = imagePreviewElement;
            this.cropBoxElement = cropBoxElement;
        }

        getCenterPosition() {
            const imageRect = this.imagePreviewElement.getBoundingClientRect()
            const cropBoxRect = this.cropBoxElement.getBoundingClientRect()

            const size = Math.min(imageRect.width, imageRect.height);

            console.log("Height of the image is : ", imageRect.height);
            console.log("Width of the image is : ", imageRect.width);
            console.log("left of the image is : ", imageRect.left);
            console.log("top of the image is : ", imageRect.top);     

            // Slack is how much room the square red box can move horizontally or vertically within the
            // image. This is required to get center position, because depending on the slack, we 
            // will center the red square in it.
            const horizontalSlack = imageRect.width - size;
            const verticalSlack = imageRect.height - size;

            console.log("Horizontal slack: ", horizontalSlack);
            console.log("Vertical slack", verticalSlack);     
            console.log("size : ", size);

            // Drift is how much the box needs to move relative to the imageRect so that both
            // are aligned. This is the starting point for positioning the red square aligned
            // and center to the image
            const horizontalDrift = cropBoxRect.left - imageRect.left;
            const verticalDrift = cropBoxRect.top - imageRect.top;

            console.log("Horizontal drift: ", horizontalDrift);
            console.log("Vertical drift: ", verticalDrift);

            const cropBoxStyle = window.getComputedStyle(this.cropBoxElement);

            console.log("style left text : ", cropBoxStyle.left);
            console.log("Style top string : ", cropBoxStyle.top);

            const currentLeft = parseFloat(cropBoxStyle.left.replace('px', ''));
            const currentTop = parseFloat(cropBoxStyle.top.replace('px', ''));

            // Current left and top are used to understand where the square gets loaded within the dom
            // this is important because that's the starting point for all positions for the cropBox. 
            // absolute positioning is not possible, because we can only modify the style component of
            // the element, not really the absolute posittioning
            console.log("Current left: ", currentLeft);
            console.log("current top : ", currentTop);

            const properties: CropBoxPosition = {
                left: (currentLeft - horizontalDrift) + horizontalSlack/2,
                top: (currentTop - verticalDrift) + verticalSlack/2,
                size: size
            };

            return properties;
        }

        setPosition(position: CropBoxPosition) {

            console.log(position)

            this.log()

            // Position the crop box relative to the image
            this.cropBoxElement.style.width = `${position.size}px`;
            this.cropBoxElement.style.height = `${position.size}px`;
            this.cropBoxElement.style.left = `${position.left}px`;
            this.cropBoxElement.style.top = `${position.top}px`;

            this.log()
        }

        unhide() {
            this.cropBoxElement.style.position = 'absolute';
            this.cropBoxElement.style.display = 'block';
            this.cropBoxElement.classList.remove('hidden');
        }

        hide() {
            this.cropBoxElement.classList.add('hidden');
        }

        log() {
            (window as any).debugCropElements();
        }
    }

    let cropModal: HTMLElement | null = null;
    let cropPreview: HTMLImageElement | null = null;
    let cropBox: HTMLElement | null = null;
    let cropOverlay: HTMLElement | null = null;
    let currentImageId: string | null = null;
    let selectedRatio: number | null = null;
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let cropBoxLeft = 0;
    let cropBoxTop = 0;

    type CropBoxPosition = {
        left: number;
        top: number;
        size: number;
    };

    function updateButtonStyles(selectedButton: HTMLElement) {
        // Reset all buttons to default style
        document.querySelectorAll('#crop-original, #crop-512, #crop-768, #crop-1024').forEach(button => {
            button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            button.classList.add('bg-gray-700', 'hover:bg-gray-600');
        });
        
        // Set selected button style
        selectedButton.classList.remove('bg-gray-700', 'hover:bg-gray-600');
        selectedButton.classList.add('bg-blue-600', 'hover:bg-blue-700');
    }

    function initializeCropBox() {
        if (!cropBox || !cropPreview) return;
        
        const handler = new CropboxHandler(cropPreview, cropBox);

        const targetPosition = handler.getCenterPosition();
        handler.setPosition(targetPosition);
        handler.unhide();
    }

    function handleMouseDown(e: MouseEvent) {
        if (!cropBox || !cropPreview) return;
        
        const rect = cropBox.getBoundingClientRect();
    }

    function handleMouseMove(e: MouseEvent) {
        if (!isDragging || !cropBox || !cropPreview) return;
        
        const imageRect = cropPreview.getBoundingClientRect();
        const cropBoxRect = cropBox.getBoundingClientRect();        
        
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        let newLeft = cropBoxLeft + deltaX;
        let newTop = cropBoxTop + deltaY;
        
        // Constrain to image bounds
        // newLeft = Math.max(0, Math.min(newLeft, imageRect.width - cropBox.offsetWidth));
        // newTop = Math.max(0, Math.min(newTop, imageRect.height - cropBox.offsetHeight));
        
        // cropBox.style.left = `${newLeft}px`;
        //cropBox.style.top = `${newTop}px`;
    }

    function handleMouseUp() {
        if (!cropBox) return;
        isDragging = false;
        cropBox.style.cursor = 'grab';
    }

    async function applyCrop() {
        if (!currentImageId || !cropBox) return;
        
        try {
            const blob = await cropImage(
                currentImageId,
                selectedRatio || 512, // Default to 512 if original size
                {
                    x: parseInt(cropBox.style.left),
                    y: parseInt(cropBox.style.top),
                    width: parseInt(cropBox.style.width),
                    height: parseInt(cropBox.style.height)
                }
            );
            
            const url = URL.createObjectURL(blob);
            
            // Update the fullscreen modal image
            const fullscreenImage = document.getElementById('modal-image') as HTMLImageElement;
            if (fullscreenImage) {
                fullscreenImage.src = url;
            }

            // Update the has_crop property on the image element
            const imageElement = document.querySelector(`img[data-id="${currentImageId}"]`);
            if (imageElement) {
                imageElement.setAttribute('data-has-crop', 'true');
            }
            
            // Close the crop modal
            cropModal?.classList.add('hidden');
        } catch (error) {
            console.error('Error applying crop:', error);
            // TODO: Show error message to user
        }
    }

    function updateRatio(size: number | null, button: HTMLElement) {
        selectedRatio = size;
        if (currentImageId && cropPreview) {
            // Store current dimensions
            const currentWidth = cropPreview.width;
            const currentHeight = cropPreview.height;

            if (size === null) {
                // Use original image
                cropPreview.src = getImageUrl(currentImageId);
            } else {
                // Use preview with specified size
                cropPreview.src = getImagePreviewUrl(currentImageId, size);
            }

            // After image loads, restore dimensions
            const img = cropPreview;  // Create reference to avoid null checks
            img.onload = () => {
                if (img) {  // Double check img still exists
                    // img.style.width = `${currentWidth}px`;
                    // img.style.height = `${currentHeight}px`;
                    initializeCropBox();
                }
            };
        }
        updateButtonStyles(button);
    }

    function debugElements() {
        if (!cropBox || !cropPreview) {
            console.log('Elements not found');
            return;
        }

        const imageRect = cropPreview.getBoundingClientRect();
        const cropBoxRect = cropBox.getBoundingClientRect();
        const imageStyle = window.getComputedStyle(cropPreview);
        const cropBoxStyle = window.getComputedStyle(cropBox);

        console.log('=== DEBUG INFO ===');
        console.log('Image:', {
            element: cropPreview,
            rect: imageRect,
            style: {
                width: imageStyle.width,
                height: imageStyle.height,
                position: imageStyle.position,
                display: imageStyle.display,
                margin: imageStyle.margin,
                padding: imageStyle.padding,
                transform: imageStyle.transform,
                left: imageStyle.left,
                top: imageStyle.top
            },
            offset: {
                left: cropPreview.offsetLeft,
                top: cropPreview.offsetTop,
                width: cropPreview.offsetWidth,
                height: cropPreview.offsetHeight
            },
            client: {
                left: cropPreview.clientLeft,
                top: cropPreview.clientTop,
                width: cropPreview.clientWidth,
                height: cropPreview.clientHeight
            }
        });

        console.log('Crop Box:', {
            element: cropBox,
            rect: cropBoxRect,
            style: {
                width: cropBoxStyle.width,
                height: cropBoxStyle.height,
                position: cropBoxStyle.position,
                display: cropBoxStyle.display,
                margin: cropBoxStyle.margin,
                padding: cropBoxStyle.padding,
                transform: cropBoxStyle.transform,
                left: cropBoxStyle.left,
                top: cropBoxStyle.top,
                border: cropBoxStyle.border
            },
            offset: {
                left: cropBox.offsetLeft,
                top: cropBox.offsetTop,
                width: cropBox.offsetWidth,
                height: cropBox.offsetHeight
            },
            client: {
                left: cropBox.clientLeft,
                top: cropBox.clientTop,
                width: cropBox.clientWidth,
                height: cropBox.clientHeight
            }
        });

        console.log('Relative Positions:', {
            cropBoxToImage: {
                left: cropBoxRect.left - imageRect.left,
                top: cropBoxRect.top - imageRect.top,
                right: cropBoxRect.right - imageRect.right,
                bottom: cropBoxRect.bottom - imageRect.bottom
            }
        });
    }

    // Initialize modal elements
    document.addEventListener('DOMContentLoaded', () => {
        cropModal = document.getElementById('crop-modal');
        cropPreview = document.getElementById('crop-preview') as HTMLImageElement;
        cropBox = document.getElementById('crop-box');
        cropOverlay = document.getElementById('crop-overlay');

        // Set initial cursor style
        if (cropBox) {
            cropBox.style.cursor = 'grab';
        }

        // Close button handler
        document.getElementById('close-crop-modal')?.addEventListener('click', () => {
            cropModal?.classList.add('hidden');
        });

        // Cancel button handler
        document.getElementById('cancel-crop')?.addEventListener('click', () => {
            cropModal?.classList.add('hidden');
        });

        // Apply crop button handler
        document.getElementById('apply-crop')?.addEventListener('click', applyCrop);

        // Ratio selection buttons
        const originalButton = document.getElementById('crop-original');
        const button512 = document.getElementById('crop-512');
        const button768 = document.getElementById('crop-768');
        const button1024 = document.getElementById('crop-1024');

        originalButton?.addEventListener('click', () => updateRatio(null, originalButton!));
        button512?.addEventListener('click', () => updateRatio(512, button512!));
        button768?.addEventListener('click', () => updateRatio(768, button768!));
        button1024?.addEventListener('click', () => updateRatio(1024, button1024!));

        // Mouse event handlers for crop box
        cropBox?.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    });

    // Make openCropModal available globally
    (window as any).openCropModal = (imageId: string) => {
        currentImageId = imageId;
        if (cropPreview) {
            // Start with original size
            cropPreview.src = getImageUrl(imageId);
            selectedRatio = null;
            const originalButton = document.getElementById('crop-original');
            if (originalButton) {
                updateButtonStyles(originalButton);
            }
        }
        cropModal?.classList.remove('hidden');
        initializeCropBox();
    };

    // Make debugElements available globally
    (window as any).debugCropElements = debugElements;
</script> 